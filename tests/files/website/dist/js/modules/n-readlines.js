const fs=require("fs");class LineByLine{constructor(e,t){(t=t||{}).readChunk||(t.readChunk=1024),t.newLineCharacter?t.newLineCharacter=t.newLineCharacter.charCodeAt(0):t.newLineCharacter=10,this.fd="number"==typeof e?e:fs.openSync(e,"r"),this.options=t,this.newLineCharacter=t.newLineCharacter,this.reset()}_searchInBuffer(e,t){let i=-1;for(let h=0;h<=e.length;h++){if(e[h]===t){i=h;break}}return i}reset(){this.eofReached=!1,this.linesCache=[],this.fdPosition=0}close(){fs.closeSync(this.fd),this.fd=null}_extractLines(e){let t;const i=[];let h=0,s=0;for(;;){let n=e[h++];if(n===this.newLineCharacter)t=e.slice(s,h),i.push(t),s=h;else if(void 0===n)break}let n=e.slice(s,h);return n.length&&i.push(n),i}_readChunk(e){let t,i=0;const h=[];do{const e=new Buffer.alloc(this.options.readChunk);i+=t=fs.readSync(this.fd,e,0,this.options.readChunk,this.fdPosition),this.fdPosition=this.fdPosition+t,h.push(e)}while(t&&-1===this._searchInBuffer(h[h.length-1],this.options.newLineCharacter));let s=Buffer.concat(h);return t<this.options.readChunk&&(this.eofReached=!0,s=s.slice(0,i)),i&&(this.linesCache=this._extractLines(s),e&&(this.linesCache[0]=Buffer.concat([e,this.linesCache[0]]))),i}next(){if(!this.fd)return!1;let e,t=!1;if(this.eofReached&&0===this.linesCache.length)return t;if(this.linesCache.length||(e=this._readChunk()),this.linesCache.length){(t=this.linesCache.shift())[t.length-1]!==this.newLineCharacter&&(e=this._readChunk(t))&&(t=this.linesCache.shift())}return this.eofReached&&0===this.linesCache.length&&this.close(),t&&t[t.length-1]===this.newLineCharacter&&(t=t.slice(0,t.length-1)),t}}module.exports=LineByLine;